# Cursor Rules for CRMv3 Laravel Project

## Project Overview
This is a Laravel 11 CRM application built with PHP 8.2+. The project manages companies, persons, orders, invoices, services, and related entities.

## Technology Stack
- **Framework**: Laravel 11
- **PHP Version**: 8.2+
- **Code Style**: PSR-12 (enforced via Laravel Pint)
- **Database**: MySQL/PostgreSQL (Eloquent ORM)
- **Frontend**: Blade templates, JavaScript, CSS/SCSS
- **PDF Generation**: dompdf (barryvdh/laravel-dompdf)
- **Authentication**: Laravel Sanctum, Laravel UI
- **Testing**: PHPUnit

## Code Style & Standards

### PHP Code
- Follow PSR-12 coding standards
- Use Laravel Pint for automatic code formatting (`./vendor/bin/pint`)
- Use strict types where appropriate
- Prefer type hints and return types for all methods
- Use meaningful variable and method names
- Follow Laravel naming conventions:
  - Controllers: PascalCase (e.g., `CompanyController`)
  - Models: PascalCase, singular (e.g., `Company`, `Order`)
  - Methods: camelCase (e.g., `getCurrentKyc()`)
  - Database tables: snake_case, plural (e.g., `companies`, `orders`)
  - Migrations: snake_case with timestamps

### Laravel Conventions
- **Models**: Place in `app/Models/`
  - Use `HasFactory` trait
  - Define `$fillable` or `$guarded` properties
  - Use relationship methods (hasMany, belongsTo, belongsToMany, etc.)
  - Use query scopes for reusable queries
- **Controllers**: Place in `app/Http/Controllers/`
  - Use resource controllers where appropriate
  - Keep controllers thin; move business logic to services or models
  - Use dependency injection for services
- **Migrations**: Place in `database/migrations/`
  - Use descriptive migration names with timestamps
  - Always include `up()` and `down()` methods
  - Use foreign key constraints where appropriate
- **Factories**: Place in `database/factories/`
  - Use Faker for generating test data
  - Define relationships using closures when needed
- **Seeders**: Place in `database/seeders/`
  - Use factories in seeders for consistency

### Database
- Use migrations for all schema changes
- Always include rollback functionality in migrations
- Use foreign keys with proper constraints
- Use indexes for frequently queried columns
- Use soft deletes where appropriate (`deleted_at` column)

### Routes
- Use resource routes where applicable
- Group related routes logically
- Use named routes for better maintainability
- Place API routes in `routes/api.php`
- Place web routes in `routes/web.php`

### Views (Blade)
- Place views in `resources/views/`
- Use Blade components and layouts
- Keep views clean; avoid complex logic
- Use `@csrf` for all forms
- Use route helpers instead of hardcoded URLs

### Security
- Always validate and sanitize user input
- Use Laravel's built-in validation rules
- Use CSRF protection for all forms
- Use authorization policies/gates when needed
- Never expose sensitive data in error messages
- Use prepared statements (Eloquent handles this)

### Error Handling
- Use try-catch blocks for expected errors
- Return appropriate HTTP status codes
- Use Laravel's exception handling in `app/Exceptions/Handler.php`
- Log errors appropriately

## File Organization
- Follow Laravel's default directory structure
- Group related functionality together
- Use namespaces correctly (PSR-4 autoloading)
- Keep files focused on a single responsibility

## Best Practices
1. **DRY (Don't Repeat Yourself)**: Extract common logic into reusable methods, traits, or services
2. **SOLID Principles**: Follow object-oriented design principles
3. **Eloquent Relationships**: Use relationships instead of manual joins where possible
4. **Eager Loading**: Use `with()` to prevent N+1 query problems
5. **Mass Assignment**: Always use `$fillable` or `$guarded` in models
6. **Validation**: Validate data in Form Requests or controllers
7. **Service Classes**: Consider creating service classes for complex business logic
8. **Events & Listeners**: Use events for decoupled functionality
9. **Caching**: Use Laravel's cache for expensive operations
10. **Queue Jobs**: Use queues for time-consuming tasks

## Testing
- Write tests for critical functionality
- Use factories in tests for consistent test data
- Follow Arrange-Act-Assert pattern
- Use descriptive test method names

## Code Generation
- Use Artisan commands for generating code:
  - `php artisan make:model ModelName -m` (with migration)
  - `php artisan make:controller ControllerName --resource`
  - `php artisan make:factory FactoryName`
  - `php artisan make:seeder SeederName`
  - `php artisan make:migration migration_name`

## When Making Changes
1. Always run `./vendor/bin/pint` to format code before committing
2. Test migrations both up and down
3. Ensure foreign key relationships are properly maintained
4. Update related factories/seeders when modifying models
5. Check for breaking changes in relationships
6. Verify route names are consistent

## Common Patterns in This Project
- Models use morphMany/morphOne for polymorphic relationships (e.g., KYC)
- Controllers use resource routes for CRUD operations
- Factories use closures for dynamic relationship creation
- File uploads are handled via `FileUploadController`
- PDF generation uses dompdf for invoices

## Notes
- This is a CRM system, so data integrity is critical
- Be careful when modifying relationships between entities
- Always consider data migration when changing schemas
- Keep audit trails where necessary (notes, KYC history, etc.)

